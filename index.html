<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AI Background Remover Pro</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"/>
    <style>
        :root{--red:#ef4444;--green:#22c55e;--orange:#f59e0b;--primary:#6366f1;}
        *{margin:0;padding:0;box-sizing:border-box;}
        body{font-family:'Segoe UI',system-ui,sans-serif;background:#f8fafc;color:#1e293b;min-height:100vh;}
        .bg-header{position:fixed;top:0;left:0;right:0;height:320px;background:linear-gradient(135deg,#6366f1,#a855f7);z-index:0;}
        .wrap{position:relative;z-index:1;max-width:1200px;margin:0 auto;padding:40px 20px;}
        .hero{text-align:center;padding:20px 0 40px;color:#fff;}
        .hero h1{font-size:2.4rem;font-weight:900;letter-spacing:-.02em;}
        .hero p{opacity:.85;margin-top:8px;}
        .main-card{background:#fff;border-radius:32px;box-shadow:0 20px 50px rgba(0,0,0,.08);padding:32px;margin-bottom:40px;}

        /* ── 업로드 ── */
        #upload{display:none;}
        .upload-label{display:block;border:2px dashed #cbd5e1;border-radius:24px;padding:40px 24px;
            text-align:center;cursor:pointer;transition:all .3s;background:#f1f5f9;margin-bottom:24px;}
        .upload-label:hover{border-color:var(--primary);background:#eef2ff;}
        .upload-label.has-file{padding:16px;border-style:solid;cursor:default;background:#fff;}
        .upload-icon{font-size:40px;color:var(--primary);margin-bottom:10px;}
        .file-row{display:none;align-items:center;gap:20px;text-align:left;}
        .file-row.show{display:flex;}
        .file-thumb{width:60px;height:60px;border-radius:12px;object-fit:cover;}

        /* ── 에디터 ── */
        .editor-layout{display:none;gap:24px;margin-top:24px;}
        .editor-layout.show{display:grid;grid-template-columns:1fr 300px;}
        .work-area{position:relative;background:#f8fafc;border-radius:24px;border:2px solid #f1f5f9;overflow:hidden;}
        .canvas-container{position:relative;width:100%;height:560px;
            background-image:conic-gradient(#f1f5f9 25%,white 0 50%,#f1f5f9 0 75%,white 0);
            background-size:20px 20px;cursor:crosshair;overflow:hidden;}
        #compareWrapper{position:absolute;top:0;left:0;display:inline-block;line-height:0;
            will-change:transform;opacity:0;transition:opacity .3s;transform-origin:0 0;}
        #compareWrapper.ready{opacity:1;}
        #originalOverlay{position:absolute;top:0;left:0;width:100%;height:100%;
            object-fit:cover;z-index:10;pointer-events:none;clip-path:inset(0 100% 0 0);}
        .compare-bar{position:absolute;top:0;bottom:0;width:2px;background:#fff;
            left:0;z-index:15;pointer-events:none;display:none;box-shadow:0 0 8px rgba(0,0,0,.3);}
        canvas{display:block;position:relative;z-index:5;}
        .badge-ui{position:absolute;top:16px;background:rgba(0,0,0,.6);color:#fff;
            padding:6px 14px;border-radius:50px;font-size:.75rem;z-index:20;
            pointer-events:none;backdrop-filter:blur(4px);display:flex;align-items:center;gap:8px;}
        #compBadge{left:16px;}#zoomBadge{right:16px;}
        .zoom-controls{position:absolute;top:60px;left:16px;display:flex;flex-direction:column;gap:6px;z-index:30;}
        .zoom-btn{width:40px;height:40px;border-radius:10px;border:1px solid rgba(0,0,0,.1);
            background:rgba(255,255,255,.95);color:#475569;cursor:pointer;
            display:flex;align-items:center;justify-content:center;font-size:1rem;
            transition:all .2s;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);outline:none;}
        .zoom-btn:hover{background:#fff;color:var(--primary);transform:translateY(-1px);}
        .zoom-btn.active{background:var(--primary);color:#fff;border-color:var(--primary);}

        /* ── 툴 패널 ── */
        .tool-panel{background:#fffbeb;border:2px solid #fef3c7;border-radius:24px;padding:24px;height:fit-content;}
        .sec-header{font-weight:900;color:#92400e;margin-bottom:20px;display:flex;align-items:center;gap:8px;}
        .fill-dir-btns{display:flex;flex-direction:column;gap:10px;margin-bottom:20px;}
        .fill-dir-btn{padding:14px;border-radius:14px;border:2px solid #e2e8f0;background:#fff;
            cursor:pointer;font-weight:700;transition:.2s;display:flex;align-items:center;gap:10px;outline:none;}
        .fill-dir-btn.on{border-color:var(--red);color:var(--red);background:#fef2f2;}
        .fill-dir-btn.restore-on{border-color:var(--green);color:var(--green);background:#ecfdf5;}
        .slider-group{margin-bottom:20px;}
        .slider-label{display:flex;justify-content:space-between;margin-bottom:8px;font-size:.9rem;font-weight:700;color:#92400e;}
        .fill-slider{width:100%;height:8px;appearance:none;background:#e2e8f0;border-radius:10px;}
        .fill-slider::-webkit-slider-thumb{appearance:none;width:22px;height:22px;background:var(--orange);border-radius:50%;cursor:pointer;border:3px solid #fff;}



        .bg-mini-wrap{display:flex;align-items:center;gap:10px;margin-bottom:24px;padding:8px 12px;background:#fff;border:2px solid #e2e8f0;border-radius:16px;}
        #bgColorInput{width:28px;height:28px;border:none;border-radius:6px;cursor:pointer;background:none;}
        .bg-mini-label{font-size:.85rem;font-weight:700;color:#475569;flex:1;}
        .btn-mini-trans{font-size:.75rem;color:var(--primary);background:none;border:none;cursor:pointer;text-decoration:underline;font-weight:600;}
        .action-btns{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
        .btn{padding:14px 24px;border-radius:16px;border:none;font-weight:800;cursor:pointer;
            transition:all .2s;display:inline-flex;align-items:center;justify-content:center;gap:8px;outline:none;}
        .btn-primary{background:var(--primary);color:#fff;width:100%;margin-bottom:10px;}
        .btn-success{background:var(--green);color:#fff;width:100%;}
        .btn-outline{background:#fff;border:2px solid #e2e8f0;color:#475569;}
        .btn:disabled{opacity:.5;filter:grayscale(1);cursor:not-allowed;}
        .toast{position:fixed;bottom:30px;left:50%;transform:translateX(-50%) translateY(100px);
            padding:16px 32px;background:#10b981;color:#fff;border-radius:50px;font-weight:700;transition:.4s;z-index:9999;}
        .toast.show{transform:translateX(-50%) translateY(0);}
        .fill-cursor{position:fixed;pointer-events:none;z-index:10000;display:none;}
        .fill-cursor-ring{border:2px solid var(--red);border-radius:50%;transition:width .1s,height .1s;}
        .fill-cursor-ring.restore{border-color:var(--green);}
        /* ── 탭 ── */
        .tab-bar{display:flex;background:#f1f5f9;border-radius:14px;padding:4px;margin-bottom:20px;gap:4px;}
        .tab-btn{flex:1;padding:9px 4px;border-radius:10px;border:none;background:transparent;
            cursor:pointer;font-weight:700;font-size:.8rem;color:#64748b;transition:.2s;outline:none;}
        .tab-btn.active{background:#fff;color:var(--primary);box-shadow:0 2px 8px rgba(0,0,0,.08);}
        .tab-content{display:none;}.tab-content.show{display:block;}
        /* ── 서브패널 ── */
        .sub-panel{background:#f8fafc;border:2px solid #e2e8f0;border-radius:16px;padding:14px;margin-bottom:14px;}
        .brush-row{display:flex;align-items:center;gap:8px;margin-bottom:6px;}
        .brush-row label{font-size:.78rem;color:#64748b;font-weight:600;min-width:40px;}
        .brush-slider{flex:1;height:6px;appearance:none;background:#e2e8f0;border-radius:10px;}
        .brush-slider::-webkit-slider-thumb{appearance:none;width:16px;height:16px;background:var(--primary);border-radius:50%;cursor:pointer;border:2px solid #fff;}
        .brush-val{font-size:.78rem;font-weight:700;color:var(--primary);min-width:28px;text-align:right;}
        .tip-text{font-size:.73rem;color:#94a3b8;line-height:1.5;margin-bottom:14px;}
        @media(max-width:850px){.editor-layout.show{grid-template-columns:1fr;}}
    </style>
</head>
<body>
<div class="bg-header"></div>
<div class="wrap">
    <div class="hero">
        <h1>✨ AI Background Remover</h1>
        <p>원본 비교와 세밀한 수정이 가능한 프로페셔널 편집기</p>
    </div>
    <div class="main-card">

        <input type="file" id="upload" accept="image/*">
        <label class="upload-label" id="uploadCard">
            <div id="uploadUI">
                <div class="upload-icon"><i class="fas fa-cloud-upload-alt"></i></div>
                <h3>이미지 업로드</h3>
                <p style="color:#94a3b8;margin-top:6px;font-size:.9rem;">클릭하여 파일 선택</p>
            </div>
            <div class="file-row" id="fileRow">
                <img class="file-thumb" id="thumb" src="" alt="">
                <div><h4 id="fName">-</h4><span id="fMeta" style="color:#94a3b8;font-size:.8rem;">-</span></div>
                <span class="btn btn-outline" id="reUploadBtn" style="margin-left:auto;padding:8px 16px;cursor:pointer;">변경</span>
            </div>
        </label>

        <button class="btn btn-primary" id="processBtn" disabled>
            <i class="fas fa-magic"></i> 배경 제거 시작하기
        </button>

        <div id="progWrap" style="display:none;margin:20px 0;">
            <div style="height:8px;background:#e2e8f0;border-radius:10px;overflow:hidden;">
                <div id="progressBar" style="width:0%;height:100%;background:var(--primary);transition:.3s;"></div>
            </div>
            <p id="statusText" style="text-align:center;font-size:.85rem;margin-top:8px;font-weight:600;"></p>
        </div>

        <div class="editor-layout" id="editorLayout">
            <div class="work-area">
                <div class="badge-ui" id="compBadge"><i class="fas fa-info-circle"></i> Ctrl+휠:줌 | Space+클릭:이동 | Ctrl+Z/Y:되돌리기</div>
                <div class="badge-ui" id="zoomBadge"><i class="fas fa-search"></i> <span id="zoomVal">100</span>%</div>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="manualZoom(.2)"><i class="fas fa-plus"></i></button>
                    <button class="zoom-btn" onclick="manualZoom(-.2)"><i class="fas fa-minus"></i></button>
                    <button class="zoom-btn" onclick="resetZoom(true)"><i class="fas fa-expand"></i></button>
                    <button class="zoom-btn" id="btnCompareMode" onclick="toggleCompareMode(event)"><i class="fas fa-columns"></i></button>
                </div>
                <div class="canvas-container" id="canvasContainer">
                    <div id="compareWrapper">
                        <img id="originalOverlay" src="" alt="">
                        <div class="compare-bar" id="compareBar"></div>
                        <canvas id="outputCanvas"></canvas>
                    </div>
                    <canvas id="inputCanvas" style="display:none"></canvas>
                </div>
            </div>

            <div class="tool-panel">
                <div class="sec-header" style="margin-top:0;"><i class="fas fa-paint-brush"></i> 편집 도구</div>

                <!-- 탭 -->
                <div class="tab-bar">
                    <button class="tab-btn active" id="tabMagic" onclick="switchTab('magic')">
                        <i class="fas fa-magic"></i> Magic Brush
                    </button>
                    <button class="tab-btn" id="tabFill" onclick="switchTab('fill')">
                        <i class="fas fa-fill-drip"></i> 영역 수정
                    </button>
                </div>

                <!-- Magic Brush 탭 -->
                <div class="tab-content show" id="contentMagic">
                    <p class="tip-text">브러시로 문지르면 색상을 자동 감지하여<br>배경을 제거하거나 복구합니다.</p>
                    <div class="fill-dir-btns" style="margin-bottom:14px;">
                        <button class="fill-dir-btn on" id="brushDirErase" onclick="setBrushDir('erase');this.blur();">
                            <i class="fas fa-eraser"></i> 배경 지우기
                        </button>
                        <button class="fill-dir-btn" id="brushDirRestore" onclick="setBrushDir('restore');this.blur();">
                            <i class="fas fa-undo-alt"></i> 영역 복구
                        </button>
                    </div>
                    <div class="sub-panel">
                        <div class="brush-row">
                            <label>크기</label>
                            <input type="range" class="brush-slider" id="brushSize" min="5" max="150" value="40"
                                   oninput="brushSize=+this.value;el('brushSizeVal').textContent=this.value;">
                            <span class="brush-val" id="brushSizeVal">40</span>
                        </div>
                    </div>
                </div>

                <!-- 영역 수정 탭 -->
                <div class="tab-content" id="contentFill">
                    <p class="tip-text">클릭하면 유사한 색상 영역을 자동으로<br>한 번에 제거하거나 복구합니다.</p>
                    <div class="fill-dir-btns" style="margin-bottom:14px;">
                        <button class="fill-dir-btn on" id="fillDirErase" onclick="setFillDir('erase');this.blur();">
                            <i class="fas fa-eraser"></i> 영역 자동 삭제
                        </button>
                        <button class="fill-dir-btn" id="fillDirRestore" onclick="setFillDir('restore');this.blur();">
                            <i class="fas fa-undo-alt"></i> 영역 자동 복구
                        </button>
                    </div>
                    <div class="sub-panel">
                        <div class="brush-row">
                            <label>허용치</label>
                            <input type="range" class="brush-slider" id="fillTolerance" min="1" max="150" value="32"
                                   oninput="fillTolerance=+this.value;el('fillTolVal').textContent=this.value;">
                            <span class="brush-val" id="fillTolVal">32</span>
                        </div>
                    </div>
                </div>



                <div class="bg-mini-wrap">
                    <input type="color" id="bgColorInput" value="#ffffff" oninput="changeBgColor(this.value)">
                    <span class="bg-mini-label">배경색</span>
                    <button class="btn-mini-trans" onclick="resetBgTransparent()">투명하게</button>
                </div>
                <div class="action-btns" style="margin-bottom:20px;">
                    <button class="btn btn-outline" id="fillUndoBtn" onclick="fillUndo();this.blur();" disabled><i class="fas fa-undo"></i></button>
                    <button class="btn btn-outline" id="fillRedoBtn" onclick="fillRedo();this.blur();" disabled><i class="fas fa-redo"></i></button>
                </div>
                <button class="btn btn-success" id="downloadBtn"><i class="fas fa-download"></i> 결과 저장 (PNG)</button>
            </div>
        </div>
    </div>
</div>
<div class="fill-cursor" id="fillCursor" style="transform:translate(-50%,-50%);"><div class="fill-cursor-ring" id="fillCursorRing" style="width:30px;height:30px;"></div></div>
<div class="toast" id="toastEl">✅ 완료!</div>

<script>
// Cloudflare Workers AI 엔드포인트
const WORKERS_URL = 'https://nukki.kjy30711.workers.dev';

let origData=null, isCompareMode=false;
let scale=1, posX=0, posY=0, isDragging=false, isSpacePressed=false, lastMouseX=0, lastMouseY=0;
let currentBgColor='transparent', compareJustOff=false;
let fillTolerance=32, fillDir='erase';
let brushSize=40;
let isBrushPainting=false;
const undoStack=[], redoStack=[];
let initialImageData=null;
let rawAlpha=null;   // Workers AI 결과 알파채널

const el = id => document.getElementById(id);
const elUpload       = el('upload');
const elUploadCard   = el('uploadCard');
const elProcessBtn   = el('processBtn');
const elDownloadBtn  = el('downloadBtn');
const elProgressBar  = el('progressBar');
const elStatusText   = el('statusText');
const elProgWrap     = el('progWrap');
const elInputCanvas  = el('inputCanvas');
const elOutputCanvas = el('outputCanvas');
const elEditorLayout = el('editorLayout');
const elOrigOverlay  = el('originalOverlay');
const elCmpWrapper   = el('compareWrapper');
const elCmpBar       = el('compareBar');
const elCmpContainer = el('canvasContainer');

/* ── 유틸 ── */
function showToast(msg){const t=el('toastEl');t.textContent=msg;t.classList.add('show');setTimeout(()=>t.classList.remove('show'),2200);}
function setProgress(pct,txt){elProgWrap.style.display='block';elProgressBar.style.width=pct+'%';elStatusText.textContent=txt;if(pct>=100)setTimeout(()=>elProgWrap.style.display='none',2000);}

/* ── 배경색 ── */
function changeBgColor(c){currentBgColor=c;elCmpContainer.style.backgroundImage='none';elCmpContainer.style.backgroundColor=c;}
function resetBgTransparent(){currentBgColor='transparent';elCmpContainer.style.backgroundColor='transparent';elCmpContainer.style.backgroundImage='conic-gradient(#f1f5f9 25%,white 0 50%,#f1f5f9 0 75%,white 0)';showToast('투명 배경으로 설정됨');}

/* ── 키보드 ── */
window.addEventListener('keydown',e=>{
    if(e.code==='Space'){if(e.target.tagName!=='INPUT'&&e.target.tagName!=='TEXTAREA')e.preventDefault();isSpacePressed=true;if(elEditorLayout.classList.contains('show'))elCmpContainer.style.cursor='grab';}
    if(e.ctrlKey&&e.code==='KeyZ'){e.preventDefault();fillUndo();}
    if(e.ctrlKey&&e.code==='KeyY'){e.preventDefault();fillRedo();}
});
window.addEventListener('keyup',e=>{if(e.code==='Space'){isSpacePressed=false;elCmpContainer.style.cursor='crosshair';}});

/* ── 줌/패닝 ── */
elCmpContainer.addEventListener('wheel',e=>{if(!e.ctrlKey)return;e.preventDefault();const r=elCmpContainer.getBoundingClientRect();applyZoom(e.deltaY>0?-.08:.08,e.clientX-r.left,e.clientY-r.top);},{passive:false});
function manualZoom(d){applyZoom(d,elCmpContainer.offsetWidth/2,elCmpContainer.offsetHeight/2);}
function applyZoom(d,mx,my){const tx=(mx-posX)/scale,ty=(my-posY)/scale;scale=Math.min(Math.max(.1,scale+d),10);posX=mx-tx*scale;posY=my-ty*scale;updateTransform();}
elCmpContainer.addEventListener('mousedown',e=>{if(isSpacePressed&&e.button===0){isDragging=true;lastMouseX=e.clientX;lastMouseY=e.clientY;elCmpContainer.style.cursor='grabbing';e.preventDefault();}});
window.addEventListener('mousemove',e=>{
    if(isCompareMode){const r=elOutputCanvas.getBoundingClientRect();const p=Math.max(0,Math.min(100,(((e.clientX-r.left)/scale)/elOutputCanvas.width)*100));elOrigOverlay.style.clipPath=`inset(0 ${100-p}% 0 0)`;elCmpBar.style.left=p+'%';elCmpBar.style.display='block';}
    if(isDragging){posX+=e.clientX-lastMouseX;posY+=e.clientY-lastMouseY;lastMouseX=e.clientX;lastMouseY=e.clientY;updateTransform();}
});
window.addEventListener('mouseup',()=>{isDragging=false;elCmpContainer.style.cursor=isSpacePressed?'grab':'crosshair';});
elCmpContainer.addEventListener('contextmenu',e=>e.preventDefault());
function updateTransform(){elCmpWrapper.style.transform=`translate(${posX}px,${posY}px) scale(${scale})`;el('zoomVal').textContent=Math.round(scale*100);}
function resetZoom(msg=false){const iw=elOutputCanvas.width,ih=elOutputCanvas.height;if(!iw||!ih)return;const cw=elCmpContainer.offsetWidth,ch=elCmpContainer.offsetHeight;scale=Math.min((cw*.98)/iw,(ch*.98)/ih);posX=(cw-iw*scale)/2;posY=(ch-ih*scale)/2;updateTransform();if(msg)showToast('화면에 맞게 정렬됨');}
function toggleCompareMode(e){if(e){e.preventDefault();e.currentTarget.blur();}isCompareMode=!isCompareMode;const btn=el('btnCompareMode');if(isCompareMode){btn.classList.add('active');showToast('원본 비교 모드 ON');}else{btn.classList.remove('active');elOrigOverlay.style.clipPath='inset(0 100% 0 0)';elCmpBar.style.display='none';compareJustOff=true;setTimeout(()=>{compareJustOff=false;},200);}}

/* ── 파일 업로드 ── */
// uploadCard 클릭 → 파일 선택 (has-file 여부 무관하게 직접 input.click)
elUploadCard.addEventListener('click', e=>{
    // 변경 버튼 클릭은 별도 처리
    if(e.target.id==='reUploadBtn' || e.target.closest('#reUploadBtn')) return;
    // has-file 상태가 아닐 때만 (has-file이면 변경 버튼으로만)
    if(!elUploadCard.classList.contains('has-file')) elUpload.click();
});

elUpload.addEventListener('change',e=>{
    const file=e.target.files[0];if(!file)return;
    const reader=new FileReader();
    reader.onload=()=>{
        const img=new Image();
        img.onload=()=>{
            elInputCanvas.width=img.width;elInputCanvas.height=img.height;
            elInputCanvas.getContext('2d').drawImage(img,0,0);
            elOrigOverlay.src=reader.result;
            el('thumb').src=reader.result;
            el('fName').textContent=file.name;
            el('fMeta').textContent=img.width+'×'+img.height;
            el('uploadUI').style.display='none';
            el('fileRow').classList.add('show');
            elUploadCard.classList.add('has-file');
            elProcessBtn.disabled=false;
            elEditorLayout.classList.remove('show');
            elCmpWrapper.classList.remove('ready');
            undoStack.length=0;redoStack.length=0;updateUndoBtns();
        };
        img.src=reader.result;
    };
    reader.readAsDataURL(file);
});

el('reUploadBtn').addEventListener('click',e=>{
    e.stopPropagation();
    // value 초기화해서 같은 파일 재선택도 change 이벤트 발생
    elUpload.value='';
    elUpload.click();
});

/* ══════════════════════════════════════════════════════
   Cloudflare Workers AI 파이프라인
   - Workers에서 배경제거 PNG 반환
   - 반환된 PNG에서 알파채널 추출 → rawAlpha 저장
   - 이후 Magic Brush / Flood Fill 편집 가능
══════════════════════════════════════════════════════ */

/* ── 합성 함수 (rawAlpha → 캔버스 출력) ── */
function applyAndComposite(){
    if(!rawAlpha || !origData) return;
    const W=origData.width, H=origData.height, n2=W*H;
    const d=origData.data;
    const outCtx=elOutputCanvas.getContext('2d');
    const outImg=outCtx.createImageData(W,H);
    for(let i=0;i<n2;i++){
        const a=Math.round(Math.max(0,Math.min(255,rawAlpha[i])));
        outImg.data[i*4]  =d[i*4];
        outImg.data[i*4+1]=d[i*4+1];
        outImg.data[i*4+2]=d[i*4+2];
        outImg.data[i*4+3]=a;
    }
    outCtx.putImageData(outImg,0,0);
}

/* ── 메인 파이프라인 ── */
elProcessBtn.addEventListener('click', async()=>{
    if(elProcessBtn.disabled) return;
    elProcessBtn.disabled=true;
    try{
        setProgress(10, '이미지 준비 중...');
        const W=elInputCanvas.width, H=elInputCanvas.height;

        // 1) 캔버스 → Blob → FormData (Content-Type 자동 설정)
        const blob = await new Promise(res => elInputCanvas.toBlob(res, 'image/png'));
        const formData = new FormData();
        formData.append('image', new File([blob], 'image.png', { type: 'image/png' }));

        setProgress(30, 'AI 배경 제거 중... (2~5초)');

        // 2) Cloudflare Workers AI 호출
        // FormData를 fetch에 넘기면 브라우저가 Content-Type: multipart/form-data; boundary=... 자동 설정
        const res = await fetch(WORKERS_URL, {
            method: 'POST',
            body: formData
            // Content-Type 헤더를 직접 설정하면 boundary가 빠져서 오류 → 브라우저 자동 설정에 맡김
        });
        if(!res.ok){
            const errText = await res.text().catch(()=>'');
            throw new Error(`서버 오류: ${res.status} ${errText}`);
        }

        setProgress(70, '결과 처리 중...');

        // 3) 반환된 PNG(투명 배경) → 캔버스에 그려서 알파 추출
        const resultBlob = await res.blob();
        const resultUrl  = URL.createObjectURL(resultBlob);
        const resultImg  = await new Promise((res, rej)=>{
            const img=new Image();
            img.onload=()=>res(img);
            img.onerror=rej;
            img.src=resultUrl;
        });

        // 4) AI 결과 PNG에서 알파채널 추출 → rawAlpha
        const tmpC=document.createElement('canvas');
        tmpC.width=W; tmpC.height=H;
        const tmpCtx=tmpC.getContext('2d');
        tmpCtx.drawImage(resultImg, 0, 0, W, H);
        const resultPx=tmpCtx.getImageData(0,0,W,H);
        URL.revokeObjectURL(resultUrl);

        const n2=W*H;
        rawAlpha=new Float32Array(n2);
        for(let i=0;i<n2;i++) rawAlpha[i]=resultPx.data[i*4+3];

        // 5) 원본 픽셀 데이터 저장
        origData=elInputCanvas.getContext('2d').getImageData(0,0,W,H);

        setProgress(90, '최종 합성 중...');

        // 6) 합성 후 출력
        elOutputCanvas.width=W; elOutputCanvas.height=H;
        applyAndComposite();

        undoStack.length=0; redoStack.length=0; updateUndoBtns();
        initialImageData=elOutputCanvas.getContext('2d').getImageData(0,0,W,H);

        setProgress(100, '완료!');
        elEditorLayout.classList.add('show');
        setTimeout(()=>{ resetZoom(); elCmpWrapper.classList.add('ready'); }, 50);
        showToast('✨ 배경 제거 완료!');

    }catch(err){
        console.error(err);
        showToast('❌ 오류: ' + err.message);
        setProgress(0,'');
    }finally{
        elProcessBtn.disabled=false;
    }
});

/* ── Undo/Redo ── */
function setFillDir(d){if(isCompareMode)toggleCompareMode();fillDir=d;el('fillDirErase').className='fill-dir-btn'+(d==='erase'?' on':'');el('fillDirRestore').className='fill-dir-btn'+(d==='restore'?' restore-on':'');}
function fillUndo(){if(undoStack.length===0){if(initialImageData){elOutputCanvas.getContext('2d').putImageData(initialImageData,0,0);showToast('최초 상태입니다.');}return;}redoStack.push(elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height));elOutputCanvas.getContext('2d').putImageData(undoStack.pop(),0,0);updateUndoBtns();showToast('실행 취소됨');}
function fillRedo(){if(redoStack.length===0)return;undoStack.push(elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height));elOutputCanvas.getContext('2d').putImageData(redoStack.pop(),0,0);updateUndoBtns();showToast('다시 실행됨');}
function updateUndoBtns(){el('fillUndoBtn').disabled=(undoStack.length===0&&!initialImageData);el('fillRedoBtn').disabled=(redoStack.length===0);}

/* ══════════════════════════════════════════════
   Magic Brush — remove.bg 방식 구현
   브러시가 지나간 각 점에서 Flood Fill 실행
   → 색상 유사 영역을 자동으로 확장해서 제거/복구
   단순 알파 지우개가 아닌 스마트 감지 방식
══════════════════════════════════════════════ */
let brushDir = 'erase';
let activeTab = 'magic'; // 'magic' | 'fill'

function switchTab(tab){
    activeTab = tab;
    // 탭 버튼 스타일
    el('tabMagic').className = 'tab-btn' + (tab==='magic' ? ' active' : '');
    el('tabFill').className  = 'tab-btn' + (tab==='fill'  ? ' active' : '');
    // 탭 콘텐츠 표시
    el('contentMagic').className = 'tab-content' + (tab==='magic' ? ' show' : '');
    el('contentFill').className  = 'tab-content' + (tab==='fill'  ? ' show' : '');
    // 커서 색 갱신
    updateCursorColor();
}

function updateCursorColor(){
    const isRestore = activeTab==='magic' ? brushDir==='restore' : fillDir==='restore';
    el('fillCursorRing').className = 'fill-cursor-ring' + (isRestore ? ' restore' : '');
}
let lastBrushX=-999, lastBrushY=-999; // 이전 브러시 위치 (중복 실행 방지)

function setBrushDir(d){
    brushDir=d;
    el('brushDirErase').className='fill-dir-btn'+(d==='erase'?' on':'');
    el('brushDirRestore').className='fill-dir-btn'+(d==='restore'?' restore-on':'');
}

function updateBrushCursor(){
    const ring=el('fillCursorRing');
    const sz=Math.max(10, brushSize*scale);
    ring.style.width=sz+'px'; ring.style.height=sz+'px';
}

/* ── 캔버스 마우스 이벤트 ── */
elOutputCanvas.addEventListener('mousedown',e=>{
    if(isCompareMode||isSpacePressed||compareJustOff||!origData||e.button!==0) return;
    if(activeTab!=='magic') return; // Magic Brush 탭일 때만
    isBrushPainting=true;
    lastBrushX=-999; lastBrushY=-999;
    const _snap=elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height);
    undoStack.push(_snap);
    redoStack.length=0; updateUndoBtns();
    _brushCache=null; // 새 스트로크 시작 시 캐시 초기화
    const {cx,cy}=canvasXY(e);
    magicBrushAt(cx,cy);
});

window.addEventListener('mouseup',()=>{
    if(isBrushPainting){
        _brushCache=null; // 스트로크 완료 시 캐시 해제
    }
    isBrushPainting=false;
});

elOutputCanvas.addEventListener('click',e=>{
    if(isCompareMode||isSpacePressed||compareJustOff||!origData) return;
    if(activeTab!=='fill') return; // 영역 수정 탭일 때만
    const {cx,cy}=canvasXY(e);
    undoStack.push(elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height));
    redoStack.length=0; updateUndoBtns();
    floodFill(cx,cy,fillDir==='erase');
});

elOutputCanvas.addEventListener('mousemove',e=>{
    const fc=el('fillCursor');
    if(isCompareMode||isSpacePressed){fc.style.display='none';return;}
    fc.style.display='block';
    fc.style.left=e.clientX+'px'; fc.style.top=e.clientY+'px';
    updateBrushCursor();
    updateCursorColor();

    if(isBrushPainting && activeTab==='magic'){
        const {cx,cy}=canvasXY(e);
        const r=Math.round(brushSize/2);
        const moved=Math.abs(cx-lastBrushX)>r*0.4 || Math.abs(cy-lastBrushY)>r*0.4;
        if(moved){ magicBrushAt(cx,cy); lastBrushX=cx; lastBrushY=cy; }
    }
});
elOutputCanvas.addEventListener('mouseleave',()=>el('fillCursor').style.display='none');

function canvasXY(e){
    const rect=elOutputCanvas.getBoundingClientRect();
    return {
        cx: Math.round(((e.clientX-rect.left)/rect.width)*elOutputCanvas.width),
        cy: Math.round(((e.clientY-rect.top)/rect.height)*elOutputCanvas.height)
    };
}

/* ══════════════════════════════════════════════════
   Magic Brush — 올바른 구현
   
   핵심 원칙:
   - Flood Fill 전파 완전 제거 (엉뚱한 영역 번짐 방지)
   - 브러시 반경 안 픽셀만 처리 (정확한 범위 제어)
   - Erase: 브러시 범위 내 픽셀 알파를 0으로
   - Restore: rawAlpha 기준으로 원본 알파 복원
   - 거리 기반 강도: 중심은 강하게, 가장자리는 부드럽게
══════════════════════════════════════════════════ */
// getImageData 캐시 (드래그 중 반복 호출 최적화)
let _brushCache = null;

function magicBrushAt(cx, cy){
    if(!origData || !rawAlpha) return;
    const w=elOutputCanvas.width, h=elOutputCanvas.height;
    const ctx=elOutputCanvas.getContext('2d');
    const r=Math.round(brushSize/2);
    const isErase=brushDir==='erase';

    if(!_brushCache) _brushCache=ctx.getImageData(0,0,w,h);
    const od=_brushCache.data;
    const src=origData.data;

    for(let dy=-r; dy<=r; dy++){
        for(let dx=-r; dx<=r; dx++){
            const dist=Math.sqrt(dx*dx+dy*dy);
            if(dist>r) continue;
            const px=cx+dx, py=cy+dy;
            if(px<0||px>=w||py<0||py>=h) continue;

            const idx=(py*w+px)*4;
            const origA=rawAlpha[py*w+px]; // AI 원본 판단값
            const strength=Math.pow(1-dist/r, 0.5);

            if(isErase){
                // ══ Erase: rawAlpha 기준으로 "배경 픽셀"만 지움 ══
                // rawAlpha >= 200 = AI가 확실한 전경으로 판단 → 절대 건드리지 않음
                if(origA >= 200) continue;
                // rawAlpha 0~199 = 배경 또는 반투명 경계 → 지움
                // rawAlpha가 낮을수록 더 강하게 지움 (확실한 배경은 강하게, 경계는 부드럽게)
                const eraseStr=strength * (1 - origA/200);
                od[idx+3]=Math.max(0, Math.round(od[idx+3]*(1-eraseStr)));

            } else {
                // ══ Restore: rawAlpha 기준으로 "전경 픽셀"만 복원 ══
                // rawAlpha < 30 = AI가 확실한 배경으로 판단 → 절대 복구하지 않음
                if(origA < 30) continue;
                // rawAlpha 30~255 = 전경 또는 반투명 경계 → 원본으로 복원
                const targetA=origA;
                od[idx+3]=Math.min(255, Math.round(od[idx+3]+(targetA-od[idx+3])*strength));
                od[idx]  =Math.round(od[idx]  +(src[idx]  -od[idx]  )*strength);
                od[idx+1]=Math.round(od[idx+1]+(src[idx+1]-od[idx+1])*strength);
                od[idx+2]=Math.round(od[idx+2]+(src[idx+2]-od[idx+2])*strength);
            }
        }
    }
    ctx.putImageData(_brushCache,0,0);
}

function floodFill(sx,sy,isErase){
    const w=elOutputCanvas.width,h=elOutputCanvas.height;
    const ctx=elOutputCanvas.getContext('2d');
    const out=ctx.getImageData(0,0,w,h),od=out.data,src=origData.data;
    const si=(sy*w+sx)*4;
    const sr=src[si],sg=src[si+1],sb=src[si+2];
    const tol=fillTolerance*fillTolerance*3;
    const vis=new Uint8Array(w*h);
    const stk=[sy*w+sx]; vis[sy*w+sx]=1;
    while(stk.length){
        const idx=stk.pop(),pi=idx*4;
        const dr=src[pi]-sr,dg=src[pi+1]-sg,db=src[pi+2]-sb;
        if(dr*dr+dg*dg+db*db<=tol){
            if(isErase) od[pi+3]=0;
            else{od[pi]=src[pi];od[pi+1]=src[pi+1];od[pi+2]=src[pi+2];od[pi+3]=255;}
            const px=idx%w,py=(idx/w)|0;
            if(px>0&&!vis[idx-1]){vis[idx-1]=1;stk.push(idx-1);}
            if(px<w-1&&!vis[idx+1]){vis[idx+1]=1;stk.push(idx+1);}
            if(py>0&&!vis[idx-w]){vis[idx-w]=1;stk.push(idx-w);}
            if(py<h-1&&!vis[idx+w]){vis[idx+w]=1;stk.push(idx+w);}
        }
    }
    ctx.putImageData(out,0,0);
}

/* ── 다운로드 ── */
elDownloadBtn.addEventListener('click',()=>{
    const sc=document.createElement('canvas');
    sc.width=elOutputCanvas.width;sc.height=elOutputCanvas.height;
    const sctx=sc.getContext('2d');
    if(currentBgColor!=='transparent'){sctx.fillStyle=currentBgColor;sctx.fillRect(0,0,sc.width,sc.height);}
    sctx.drawImage(elOutputCanvas,0,0);
    const a=document.createElement('a');a.download='누끼결과.png';a.href=sc.toDataURL();a.click();
});

updateUndoBtns();
</script>
</body>
</html>
