<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AI Background Remover Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"/>
    <style>
        :root{--red:#ef4444;--green:#22c55e;--orange:#f59e0b;--primary:#6366f1;}
        *{margin:0;padding:0;box-sizing:border-box;}
        body{font-family:'Segoe UI',system-ui,sans-serif;background:#f8fafc;color:#1e293b;min-height:100vh;}
        .bg-header{position:fixed;top:0;left:0;right:0;height:320px;background:linear-gradient(135deg,#6366f1,#a855f7);z-index:0;}
        .wrap{position:relative;z-index:1;max-width:1200px;margin:0 auto;padding:40px 20px;}
        .hero{text-align:center;padding:20px 0 40px;color:#fff;}
        .hero h1{font-size:2.4rem;font-weight:900;letter-spacing:-.02em;}
        .hero p{opacity:.85;margin-top:8px;}
        .main-card{background:#fff;border-radius:32px;box-shadow:0 20px 50px rgba(0,0,0,.08);padding:32px;margin-bottom:40px;}

        /* ── 업로드 ── */
        #upload{display:none;}
        .upload-label{display:block;border:2px dashed #cbd5e1;border-radius:24px;padding:40px 24px;
            text-align:center;cursor:pointer;transition:all .3s;background:#f1f5f9;margin-bottom:24px;}
        .upload-label:hover{border-color:var(--primary);background:#eef2ff;}
        .upload-label.has-file{padding:16px;border-style:solid;cursor:default;background:#fff;}
        .upload-icon{font-size:40px;color:var(--primary);margin-bottom:10px;}
        .file-row{display:none;align-items:center;gap:20px;text-align:left;}
        .file-row.show{display:flex;}
        .file-thumb{width:60px;height:60px;border-radius:12px;object-fit:cover;}

        /* ── 에디터 ── */
        .editor-layout{display:none;gap:24px;margin-top:24px;}
        .editor-layout.show{display:grid;grid-template-columns:1fr 300px;}
        .work-area{position:relative;background:#f8fafc;border-radius:24px;border:2px solid #f1f5f9;overflow:hidden;}
        .canvas-container{position:relative;width:100%;height:560px;
            background-image:conic-gradient(#f1f5f9 25%,white 0 50%,#f1f5f9 0 75%,white 0);
            background-size:20px 20px;cursor:crosshair;overflow:hidden;}
        #compareWrapper{position:absolute;top:0;left:0;display:inline-block;line-height:0;
            will-change:transform;opacity:0;transition:opacity .3s;transform-origin:0 0;}
        #compareWrapper.ready{opacity:1;}
        #originalOverlay{position:absolute;top:0;left:0;width:100%;height:100%;
            object-fit:cover;z-index:10;pointer-events:none;clip-path:inset(0 100% 0 0);}
        .compare-bar{position:absolute;top:0;bottom:0;width:2px;background:#fff;
            left:0;z-index:15;pointer-events:none;display:none;box-shadow:0 0 8px rgba(0,0,0,.3);}
        canvas{display:block;position:relative;z-index:5;}
        .badge-ui{position:absolute;top:16px;background:rgba(0,0,0,.6);color:#fff;
            padding:6px 14px;border-radius:50px;font-size:.75rem;z-index:20;
            pointer-events:none;backdrop-filter:blur(4px);display:flex;align-items:center;gap:8px;}
        #compBadge{left:16px;}#zoomBadge{right:16px;}
        .zoom-controls{position:absolute;top:60px;left:16px;display:flex;flex-direction:column;gap:6px;z-index:30;}
        .zoom-btn{width:40px;height:40px;border-radius:10px;border:1px solid rgba(0,0,0,.1);
            background:rgba(255,255,255,.95);color:#475569;cursor:pointer;
            display:flex;align-items:center;justify-content:center;font-size:1rem;
            transition:all .2s;box-shadow:0 4px 6px -1px rgba(0,0,0,.1);outline:none;}
        .zoom-btn:hover{background:#fff;color:var(--primary);transform:translateY(-1px);}
        .zoom-btn.active{background:var(--primary);color:#fff;border-color:var(--primary);}

        /* ── 툴 패널 ── */
        .tool-panel{background:#fffbeb;border:2px solid #fef3c7;border-radius:24px;padding:24px;height:fit-content;}
        .sec-header{font-weight:900;color:#92400e;margin-bottom:20px;display:flex;align-items:center;gap:8px;}
        .fill-dir-btns{display:flex;flex-direction:column;gap:10px;margin-bottom:20px;}
        .fill-dir-btn{padding:14px;border-radius:14px;border:2px solid #e2e8f0;background:#fff;
            cursor:pointer;font-weight:700;transition:.2s;display:flex;align-items:center;gap:10px;outline:none;}
        .fill-dir-btn.on{border-color:var(--red);color:var(--red);background:#fef2f2;}
        .fill-dir-btn.restore-on{border-color:var(--green);color:var(--green);background:#ecfdf5;}
        .slider-group{margin-bottom:20px;}
        .slider-label{display:flex;justify-content:space-between;margin-bottom:8px;font-size:.9rem;font-weight:700;color:#92400e;}
        .fill-slider{width:100%;height:8px;appearance:none;background:#e2e8f0;border-radius:10px;}
        .fill-slider::-webkit-slider-thumb{appearance:none;width:22px;height:22px;background:var(--orange);border-radius:50%;cursor:pointer;border:3px solid #fff;}

        /* 엣지 페더링 패널만 유지 */
        .feather-panel{background:#f0fdf4;border:2px solid #bbf7d0;border-radius:16px;padding:16px;margin-bottom:20px;}
        .feather-title{font-size:.82rem;font-weight:900;color:#166534;margin-bottom:12px;display:flex;align-items:center;gap:6px;}
        .post-toggle-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;font-size:.82rem;font-weight:700;color:#166534;}
        .toggle-switch{position:relative;width:36px;height:20px;flex-shrink:0;}
        .toggle-switch input{opacity:0;width:0;height:0;}
        .toggle-slider{position:absolute;inset:0;background:#cbd5e1;border-radius:20px;cursor:pointer;transition:.2s;}
        .toggle-slider:before{content:'';position:absolute;width:14px;height:14px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:.2s;}
        input:checked+.toggle-slider{background:#22c55e;}
        input:checked+.toggle-slider:before{transform:translateX(16px);}
        .sub-slider-row{display:flex;align-items:center;gap:8px;padding-left:4px;}
        .sub-slider-row label{font-size:.78rem;color:#166534;font-weight:600;white-space:nowrap;min-width:50px;}
        .post-slider-mini{flex:1;height:6px;appearance:none;background:#e2e8f0;border-radius:10px;}
        .post-slider-mini::-webkit-slider-thumb{appearance:none;width:16px;height:16px;background:#22c55e;border-radius:50%;cursor:pointer;border:2px solid #fff;}
        .sub-val{font-size:.78rem;font-weight:700;color:#166534;min-width:18px;text-align:right;}

        .bg-mini-wrap{display:flex;align-items:center;gap:10px;margin-bottom:24px;padding:8px 12px;background:#fff;border:2px solid #e2e8f0;border-radius:16px;}
        #bgColorInput{width:28px;height:28px;border:none;border-radius:6px;cursor:pointer;background:none;}
        .bg-mini-label{font-size:.85rem;font-weight:700;color:#475569;flex:1;}
        .btn-mini-trans{font-size:.75rem;color:var(--primary);background:none;border:none;cursor:pointer;text-decoration:underline;font-weight:600;}
        .action-btns{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
        .btn{padding:14px 24px;border-radius:16px;border:none;font-weight:800;cursor:pointer;
            transition:all .2s;display:inline-flex;align-items:center;justify-content:center;gap:8px;outline:none;}
        .btn-primary{background:var(--primary);color:#fff;width:100%;margin-bottom:10px;}
        .btn-success{background:var(--green);color:#fff;width:100%;}
        .btn-outline{background:#fff;border:2px solid #e2e8f0;color:#475569;}
        .btn:disabled{opacity:.5;filter:grayscale(1);cursor:not-allowed;}
        .toast{position:fixed;bottom:30px;left:50%;transform:translateX(-50%) translateY(100px);
            padding:16px 32px;background:#10b981;color:#fff;border-radius:50px;font-weight:700;transition:.4s;z-index:9999;}
        .toast.show{transform:translateX(-50%) translateY(0);}
        .fill-cursor{position:fixed;pointer-events:none;z-index:10000;display:none;}
        .fill-cursor-ring{width:30px;height:30px;border:2px solid var(--red);border-radius:50%;}
        .fill-cursor-ring.restore{border-color:var(--green);}
        @media(max-width:850px){.editor-layout.show{grid-template-columns:1fr;}}
    </style>
</head>
<body>
<div class="bg-header"></div>
<div class="wrap">
    <div class="hero">
        <h1>✨ AI Background Remover</h1>
        <p>원본 비교와 세밀한 수정이 가능한 프로페셔널 편집기</p>
    </div>
    <div class="main-card">

        <input type="file" id="upload" accept="image/*">
        <label class="upload-label" id="uploadCard" for="upload">
            <div id="uploadUI">
                <div class="upload-icon"><i class="fas fa-cloud-upload-alt"></i></div>
                <h3>이미지 업로드</h3>
                <p style="color:#94a3b8;margin-top:6px;font-size:.9rem;">클릭하여 파일 선택</p>
            </div>
            <div class="file-row" id="fileRow">
                <img class="file-thumb" id="thumb" src="" alt="">
                <div><h4 id="fName">-</h4><span id="fMeta" style="color:#94a3b8;font-size:.8rem;">-</span></div>
                <span class="btn btn-outline" id="reUploadBtn" style="margin-left:auto;padding:8px 16px;cursor:pointer;">변경</span>
            </div>
        </label>

        <button class="btn btn-primary" id="processBtn" disabled>
            <i class="fas fa-magic"></i> 배경 제거 시작하기
        </button>

        <div id="progWrap" style="display:none;margin:20px 0;">
            <div style="height:8px;background:#e2e8f0;border-radius:10px;overflow:hidden;">
                <div id="progressBar" style="width:0%;height:100%;background:var(--primary);transition:.3s;"></div>
            </div>
            <p id="statusText" style="text-align:center;font-size:.85rem;margin-top:8px;font-weight:600;"></p>
        </div>

        <div class="editor-layout" id="editorLayout">
            <div class="work-area">
                <div class="badge-ui" id="compBadge"><i class="fas fa-info-circle"></i> Ctrl+휠:줌 | Space+클릭:이동 | Ctrl+Z/Y:되돌리기</div>
                <div class="badge-ui" id="zoomBadge"><i class="fas fa-search"></i> <span id="zoomVal">100</span>%</div>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="manualZoom(.2)"><i class="fas fa-plus"></i></button>
                    <button class="zoom-btn" onclick="manualZoom(-.2)"><i class="fas fa-minus"></i></button>
                    <button class="zoom-btn" onclick="resetZoom(true)"><i class="fas fa-expand"></i></button>
                    <button class="zoom-btn" id="btnCompareMode" onclick="toggleCompareMode(event)"><i class="fas fa-columns"></i></button>
                </div>
                <div class="canvas-container" id="canvasContainer">
                    <div id="compareWrapper">
                        <img id="originalOverlay" src="" alt="">
                        <div class="compare-bar" id="compareBar"></div>
                        <canvas id="outputCanvas"></canvas>
                    </div>
                    <canvas id="inputCanvas" style="display:none"></canvas>
                </div>
            </div>

            <div class="tool-panel">
                <div class="sec-header"><i class="fas fa-paint-brush"></i> 스마트 자동 수정</div>
                <div class="fill-dir-btns">
                    <button class="fill-dir-btn on" id="fillDirErase" onclick="setFillDir('erase');this.blur();">
                        <i class="fas fa-eraser"></i> 영역 자동 삭제 (Erase)
                    </button>
                    <button class="fill-dir-btn" id="fillDirRestore" onclick="setFillDir('restore');this.blur();">
                        <i class="fas fa-undo-alt"></i> 영역 자동 복구 (Restore)
                    </button>
                </div>
                <div class="slider-group">
                    <div class="slider-label"><span>감지 허용 오차</span><span id="fillTolVal">32</span></div>
                    <input type="range" class="fill-slider" id="fillTolerance" min="1" max="150" value="32"
                           oninput="fillTolerance=+this.value;document.getElementById('fillTolVal').textContent=this.value">
                </div>

                <!-- 엣지 전용 페더링만 유지 -->
                <div class="feather-panel">
                    <div class="feather-title"><i class="fas fa-feather-alt"></i> 엣지 페더링</div>
                    <div class="post-toggle-row">
                        <span>엣지 전용 페더링</span>
                        <label class="toggle-switch"><input type="checkbox" id="optFeather" checked><span class="toggle-slider"></span></label>
                    </div>
                    <div class="sub-slider-row">
                        <label>반경</label>
                        <input type="range" class="post-slider-mini" id="featherRadius" min="1" max="6" value="2"
                               oninput="document.getElementById('featherVal').textContent=this.value">
                        <span class="sub-val" id="featherVal">2</span>
                    </div>
                </div>

                <div class="bg-mini-wrap">
                    <input type="color" id="bgColorInput" value="#ffffff" oninput="changeBgColor(this.value)">
                    <span class="bg-mini-label">배경색</span>
                    <button class="btn-mini-trans" onclick="resetBgTransparent()">투명하게</button>
                </div>
                <div class="action-btns" style="margin-bottom:20px;">
                    <button class="btn btn-outline" id="fillUndoBtn" onclick="fillUndo();this.blur();" disabled><i class="fas fa-undo"></i></button>
                    <button class="btn btn-outline" id="fillRedoBtn" onclick="fillRedo();this.blur();" disabled><i class="fas fa-redo"></i></button>
                </div>
                <button class="btn btn-success" id="downloadBtn"><i class="fas fa-download"></i> 결과 저장 (PNG)</button>
            </div>
        </div>
    </div>
</div>
<div class="fill-cursor" id="fillCursor"><div class="fill-cursor-ring" id="fillCursorRing"></div></div>
<div class="toast" id="toastEl">✅ 완료!</div>

<script>
/*
 * 모델 전략 (remove.bg 방식 참고)
 * ─────────────────────────────────────────────────────
 * RMBG-2.0: BriaAI의 최신 범용 배경 제거 모델
 *   - RMBG-1.4 대비 복잡한 배경, 어두운 배경, 반투명 객체에서 대폭 개선
 *   - IS-Net 아키텍처 기반, 1024×1024 입력
 *
 * 전처리: 이미지 정규화 (ImageNet mean/std) → 모델 정확도 향상
 * 후처리: 엣지 전용 페더링 (내부 픽셀 보존, 경계만 블러)
 * ─────────────────────────────────────────────────────
 */
// RMBG-1.4: 로그인 없이 브라우저에서 직접 사용 가능한 최고 품질 공개 모델
const MODEL_URL  = 'https://huggingface.co/briaai/RMBG-1.4/resolve/main/onnx/model.onnx';
const MODEL_SIZE = 1024;

// RMBG-1.4 공식 정규화: /255 후 mean=0.5 빼기, std=1.0 (즉 -0.5 shift만)
const MEAN = [0.5, 0.5, 0.5];
const STD  = [1.0, 1.0, 1.0];

let session=null, origData=null, isCompareMode=false;
let scale=1, posX=0, posY=0, isDragging=false, isSpacePressed=false, lastMouseX=0, lastMouseY=0;
let currentBgColor='transparent', isModelLoading=false, compareJustOff=false;
let fillTolerance=32, fillDir='erase';
const undoStack=[], redoStack=[];
let initialImageData=null;

const el = id => document.getElementById(id);
const elUpload       = el('upload');
const elUploadCard   = el('uploadCard');
const elProcessBtn   = el('processBtn');
const elDownloadBtn  = el('downloadBtn');
const elProgressBar  = el('progressBar');
const elStatusText   = el('statusText');
const elProgWrap     = el('progWrap');
const elInputCanvas  = el('inputCanvas');
const elOutputCanvas = el('outputCanvas');
const elEditorLayout = el('editorLayout');
const elOrigOverlay  = el('originalOverlay');
const elCmpWrapper   = el('compareWrapper');
const elCmpBar       = el('compareBar');
const elCmpContainer = el('canvasContainer');

/* ── 유틸 ── */
function showToast(msg){const t=el('toastEl');t.textContent=msg;t.classList.add('show');setTimeout(()=>t.classList.remove('show'),2200);}
function setProgress(pct,txt){elProgWrap.style.display='block';elProgressBar.style.width=pct+'%';elStatusText.textContent=txt;if(pct>=100)setTimeout(()=>elProgWrap.style.display='none',2000);}

/* ── 배경색 ── */
function changeBgColor(c){currentBgColor=c;elCmpContainer.style.backgroundImage='none';elCmpContainer.style.backgroundColor=c;}
function resetBgTransparent(){currentBgColor='transparent';elCmpContainer.style.backgroundColor='transparent';elCmpContainer.style.backgroundImage='conic-gradient(#f1f5f9 25%,white 0 50%,#f1f5f9 0 75%,white 0)';showToast('투명 배경으로 설정됨');}

/* ── 키보드 ── */
window.addEventListener('keydown',e=>{
    if(e.code==='Space'){if(e.target.tagName!=='INPUT'&&e.target.tagName!=='TEXTAREA')e.preventDefault();isSpacePressed=true;if(elEditorLayout.classList.contains('show'))elCmpContainer.style.cursor='grab';}
    if(e.ctrlKey&&e.code==='KeyZ'){e.preventDefault();fillUndo();}
    if(e.ctrlKey&&e.code==='KeyY'){e.preventDefault();fillRedo();}
});
window.addEventListener('keyup',e=>{if(e.code==='Space'){isSpacePressed=false;elCmpContainer.style.cursor='crosshair';}});

/* ── 줌/패닝 ── */
elCmpContainer.addEventListener('wheel',e=>{if(!e.ctrlKey)return;e.preventDefault();const r=elCmpContainer.getBoundingClientRect();applyZoom(e.deltaY>0?-.08:.08,e.clientX-r.left,e.clientY-r.top);},{passive:false});
function manualZoom(d){applyZoom(d,elCmpContainer.offsetWidth/2,elCmpContainer.offsetHeight/2);}
function applyZoom(d,mx,my){const tx=(mx-posX)/scale,ty=(my-posY)/scale;scale=Math.min(Math.max(.1,scale+d),10);posX=mx-tx*scale;posY=my-ty*scale;updateTransform();}
elCmpContainer.addEventListener('mousedown',e=>{if(isSpacePressed&&e.button===0){isDragging=true;lastMouseX=e.clientX;lastMouseY=e.clientY;elCmpContainer.style.cursor='grabbing';e.preventDefault();}});
window.addEventListener('mousemove',e=>{
    if(isCompareMode){const r=elOutputCanvas.getBoundingClientRect();const p=Math.max(0,Math.min(100,(((e.clientX-r.left)/scale)/elOutputCanvas.width)*100));elOrigOverlay.style.clipPath=`inset(0 ${100-p}% 0 0)`;elCmpBar.style.left=p+'%';elCmpBar.style.display='block';}
    if(isDragging){posX+=e.clientX-lastMouseX;posY+=e.clientY-lastMouseY;lastMouseX=e.clientX;lastMouseY=e.clientY;updateTransform();}
});
window.addEventListener('mouseup',()=>{isDragging=false;elCmpContainer.style.cursor=isSpacePressed?'grab':'crosshair';});
elCmpContainer.addEventListener('contextmenu',e=>e.preventDefault());
function updateTransform(){elCmpWrapper.style.transform=`translate(${posX}px,${posY}px) scale(${scale})`;el('zoomVal').textContent=Math.round(scale*100);}
function resetZoom(msg=false){const iw=elOutputCanvas.width,ih=elOutputCanvas.height;if(!iw||!ih)return;const cw=elCmpContainer.offsetWidth,ch=elCmpContainer.offsetHeight;scale=Math.min((cw*.98)/iw,(ch*.98)/ih);posX=(cw-iw*scale)/2;posY=(ch-ih*scale)/2;updateTransform();if(msg)showToast('화면에 맞게 정렬됨');}
function toggleCompareMode(e){if(e){e.preventDefault();e.currentTarget.blur();}isCompareMode=!isCompareMode;const btn=el('btnCompareMode');if(isCompareMode){btn.classList.add('active');showToast('원본 비교 모드 ON');}else{btn.classList.remove('active');elOrigOverlay.style.clipPath='inset(0 100% 0 0)';elCmpBar.style.display='none';compareJustOff=true;setTimeout(()=>{compareJustOff=false;},200);}}

/* ── 파일 업로드 ── */
elUpload.addEventListener('change',e=>{
    const file=e.target.files[0];if(!file)return;
    const reader=new FileReader();
    reader.onload=()=>{
        const img=new Image();
        img.onload=()=>{
            elInputCanvas.width=img.width;elInputCanvas.height=img.height;
            elInputCanvas.getContext('2d').drawImage(img,0,0);
            elOrigOverlay.src=reader.result;
            el('thumb').src=reader.result;
            el('fName').textContent=file.name;
            el('fMeta').textContent=img.width+'×'+img.height;
            el('uploadUI').style.display='none';
            el('fileRow').classList.add('show');
            elUploadCard.classList.add('has-file');
            elUploadCard.removeAttribute('for');
            elProcessBtn.disabled=false;
            elEditorLayout.classList.remove('show');
            elCmpWrapper.classList.remove('ready');
            undoStack.length=0;redoStack.length=0;updateUndoBtns();
        };
        img.src=reader.result;
    };
    reader.readAsDataURL(file);
});

el('reUploadBtn').addEventListener('click',e=>{
    e.stopPropagation();
    elUploadCard.setAttribute('for','upload');
    elUpload.click();
});

/* ── 모델 로드 ── */
async function loadModel(){
    if(session||isModelLoading)return;
    isModelLoading=true;
    try{
        setProgress(10,'AI 모델 로딩 중... (최초 1회, 약 20-40초)');
        session=await ort.InferenceSession.create(MODEL_URL,{
            executionProviders:['wasm']
        });
    }finally{isModelLoading=false;}
}

/* ══════════════════════════════════════════════════════
   전처리: ImageNet 정규화
   remove.bg 계열 모델은 단순 /255 가 아닌 mean/std 정규화가 필수.
   이것이 정확도에 가장 큰 영향을 줌.
══════════════════════════════════════════════════════ */
function preprocessImage(imageData){
    const {data, width, height} = imageData;
    const n = width * height;
    const tensor = new Float32Array(3 * n);
    for(let i=0;i<n;i++){
        tensor[i]         = (data[i*4]   / 255 - MEAN[0]) / STD[0]; // R
        tensor[i + n]     = (data[i*4+1] / 255 - MEAN[1]) / STD[1]; // G
        tensor[i + 2*n]   = (data[i*4+2] / 255 - MEAN[2]) / STD[2]; // B
    }
    return tensor;
}

/* ══════════════════════════════════════════════════════
   후처리 ①: 고립 잔여물 자동 제거
   AI가 그림자/반사광을 전경으로 오인한 작은 덩어리를
   면적 기반으로 제거. 메인 오브젝트는 절대 건드리지 않음.
══════════════════════════════════════════════════════ */
function removeIsolatedComponents(alpha, w, h, minRatio=0.002){
    const n=w*h;
    const bin=new Uint8Array(n);
    for(let i=0;i<n;i++) bin[i]=alpha[i]>=128?1:0;
    const labels=new Int32Array(n);
    const sizes=[0];
    let nextLbl=1;
    const q=[];
    for(let s=0;s<n;s++){
        if(!bin[s]||labels[s]) continue;
        labels[s]=nextLbl; q.length=0; q.push(s);
        let qi=0, sz=0;
        while(qi<q.length){
            const idx=q[qi++]; sz++;
            const px=idx%w, py=(idx/w)|0;
            if(px>0   &&bin[idx-1]&&!labels[idx-1]){labels[idx-1]=nextLbl;q.push(idx-1);}
            if(px<w-1 &&bin[idx+1]&&!labels[idx+1]){labels[idx+1]=nextLbl;q.push(idx+1);}
            if(py>0   &&bin[idx-w]&&!labels[idx-w]){labels[idx-w]=nextLbl;q.push(idx-w);}
            if(py<h-1 &&bin[idx+w]&&!labels[idx+w]){labels[idx+w]=nextLbl;q.push(idx+w);}
        }
        sizes.push(sz); nextLbl++;
    }
    const maxSz=Math.max(...sizes.slice(1),1);
    const minSz=Math.max(10,Math.floor(maxSz*minRatio));
    for(let i=0;i<n;i++) if(labels[i]>0&&sizes[labels[i]]<minSz) alpha[i]=0;
}

/* ══════════════════════════════════════════════════════
   후처리 ②: 엣지 전용 페더링
   내부(완전 불투명) 픽셀은 255 고정, 경계 픽셀만 블러 처리.
   얇은 머리카락/선 등 소실 방지.
══════════════════════════════════════════════════════ */
function featherEdgesOnly(alpha, w, h, r=2){
    // 모델이 준 알파값을 최대한 존중
    // 단순히 노이즈성 낮은 알파(10 미만)만 제거
    const n=w*h;
    for(let i=0;i<n;i++){
        if(alpha[i] < 10) alpha[i] = 0;
    }
}

/* ── 메인 파이프라인 ── */
elProcessBtn.addEventListener('click',async()=>{
    if(elProcessBtn.disabled) return;
    elProcessBtn.disabled=true;
    try{
        await loadModel();
        setProgress(30,'이미지 전처리 중...');

        const W=elInputCanvas.width, H=elInputCanvas.height;

        // ⭐ 여기서 미리 확보
        origData = elInputCanvas.getContext('2d').getImageData(0,0,W,H);

        // 이후 모델 처리 계속

        // 1) 원본을 MODEL_SIZE로 리사이즈
        const resC=document.createElement('canvas');
        resC.width=MODEL_SIZE; resC.height=MODEL_SIZE;
        resC.getContext('2d').drawImage(elInputCanvas,0,0,MODEL_SIZE,MODEL_SIZE);
        const imgD=resC.getContext('2d').getImageData(0,0,MODEL_SIZE,MODEL_SIZE);

        // 2) ImageNet 정규화 전처리
        const tensor=preprocessImage(imgD);

        setProgress(50,'AI 배경 분석 중...');

        // 3) 모델 추론
        const inputName=session.inputNames[0];
        const res=await session.run({
            [inputName]: new ort.Tensor('float32', tensor, [1,3,MODEL_SIZE,MODEL_SIZE])
        });
        const outputName=session.outputNames[0];
        const rawMask=res[outputName].data; // Float32Array

        setProgress(75,'마스크 정제 중...');

        // 4) 마스크 → 원본 해상도 업스케일
        const mC=document.createElement('canvas');mC.width=MODEL_SIZE;mC.height=MODEL_SIZE;
        const mCtx=mC.getContext('2d');
        const mImg=mCtx.createImageData(MODEL_SIZE,MODEL_SIZE);
        // 공식 postprocess_image: min-max 정규화 후 0~255 변환
        let ma=-Infinity, mi=Infinity;
        for(let i=0;i<MODEL_SIZE*MODEL_SIZE;i++){if(rawMask[i]>ma)ma=rawMask[i];if(rawMask[i]<mi)mi=rawMask[i];}
        const range=ma-mi||1e-6;
        for(let i=0;i<MODEL_SIZE*MODEL_SIZE;i++){
            const v=Math.round(((rawMask[i]-mi)/range)*255);
            mImg.data[i*4]=mImg.data[i*4+1]=mImg.data[i*4+2]=v;
            mImg.data[i*4+3]=255;
        }
        mCtx.putImageData(mImg,0,0);

        const bC=document.createElement('canvas');bC.width=W;bC.height=H;
        // bilinear 업스케일 (Canvas 기본)
        const bCtx=bC.getContext('2d');
        bCtx.imageSmoothingEnabled=true;
        bCtx.imageSmoothingQuality='high';
        bCtx.drawImage(mC,0,0,W,H);
        const bPx=bCtx.getImageData(0,0,W,H).data;

        const n2=W*H;
        const alpha=new Float32Array(n2);
        for(let i=0;i<n2;i++) alpha[i]=bPx[i*4];

        // 5-a) 고립 잔여물 자동 제거 (그림자/반사 오인 덩어리 제거)
        removeIsolatedComponents(alpha, W, H, 0.002);

        // 5-b) 엣지 전용 페더링
        if(el('optFeather').checked)
            featherEdgesOnly(alpha,W,H,parseInt(el('featherRadius').value));

        // 그 다음 SaaS 정제 적용
        applySaaSRefinement(alpha, origData, W, H);

        setProgress(92,'최종 합성 중...');

        // 6) 원본 RGB + 알파 합성 + 배경색 기반 색상 복원
        origData=elInputCanvas.getContext('2d').getImageData(0,0,W,H);
        elOutputCanvas.width=W; elOutputCanvas.height=H;
        const outCtx=elOutputCanvas.getContext('2d');
        const outImg=outCtx.createImageData(W,H);
        const d=origData.data;

        // 배경색 추정
let bgR=0,bgG=0,bgB=0,bgCnt=0;
for(let i=0;i<n2;i++){
    if(alpha[i] < 8){
        bgR+=d[i*4];
        bgG+=d[i*4+1];
        bgB+=d[i*4+2];
        bgCnt++;
    }
}
if(bgCnt>0){
    bgR/=bgCnt; bgG/=bgCnt; bgB/=bgCnt;
}

for(let i=0;i<n2;i++){
    const rawA = alpha[i];
    const a = Math.max(0, Math.min(255, Math.round(rawA)));
    const af = a / 255;

    let r = d[i*4];
    let g = d[i*4+1];
    let b = d[i*4+2];

    // 엣지 픽셀에만 디컨타미네이션
    if(af > 0.04 && af < 0.99){
        r = (r - bgR*(1-af)) / af;
        g = (g - bgG*(1-af)) / af;
        b = (b - bgB*(1-af)) / af;
    }

    outImg.data[i*4]   = Math.max(0, Math.min(255, Math.round(r)));
    outImg.data[i*4+1] = Math.max(0, Math.min(255, Math.round(g)));
    outImg.data[i*4+2] = Math.max(0, Math.min(255, Math.round(b)));
    outImg.data[i*4+3] = a;
}
        outCtx.putImageData(outImg,0,0);

        undoStack.length=0; redoStack.length=0; updateUndoBtns();
        initialImageData=outCtx.getImageData(0,0,W,H);

        setProgress(100,'완료!');
        elEditorLayout.classList.add('show');
        setTimeout(()=>{resetZoom();elCmpWrapper.classList.add('ready');},50);
        showToast('✨ 배경 제거 완료!');
    }catch(err){
        console.error(err);
        showToast('오류: '+err.message);
    }finally{
        elProcessBtn.disabled=false;
    }
});

/* ── Undo/Redo ── */
function setFillDir(d){if(isCompareMode)toggleCompareMode();fillDir=d;el('fillDirErase').className='fill-dir-btn'+(d==='erase'?' on':'');el('fillDirRestore').className='fill-dir-btn'+(d==='restore'?' restore-on':'');}
function fillUndo(){if(undoStack.length===0){if(initialImageData){elOutputCanvas.getContext('2d').putImageData(initialImageData,0,0);showToast('최초 상태입니다.');}return;}redoStack.push(elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height));elOutputCanvas.getContext('2d').putImageData(undoStack.pop(),0,0);updateUndoBtns();showToast('실행 취소됨');}
function fillRedo(){if(redoStack.length===0)return;undoStack.push(elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height));elOutputCanvas.getContext('2d').putImageData(redoStack.pop(),0,0);updateUndoBtns();showToast('다시 실행됨');}
function updateUndoBtns(){el('fillUndoBtn').disabled=(undoStack.length===0&&!initialImageData);el('fillRedoBtn').disabled=(redoStack.length===0);}

/* ── Flood Fill ── */
elOutputCanvas.addEventListener('click',e=>{
    if(isCompareMode||isSpacePressed||compareJustOff||!origData) return;
    const rect=elOutputCanvas.getBoundingClientRect();
    const x=Math.floor(((e.clientX-rect.left)/rect.width)*elOutputCanvas.width);
    const y=Math.floor(((e.clientY-rect.top)/rect.height)*elOutputCanvas.height);
    undoStack.push(elOutputCanvas.getContext('2d').getImageData(0,0,elOutputCanvas.width,elOutputCanvas.height));
    redoStack.length=0; updateUndoBtns();
    floodFill(x,y,fillDir==='erase');
});
elOutputCanvas.addEventListener('mousemove',e=>{
    const fc=el('fillCursor');
    if(isCompareMode||isSpacePressed){fc.style.display='none';return;}
    fc.style.display='block';fc.style.left=(e.clientX-15)+'px';fc.style.top=(e.clientY-15)+'px';
    el('fillCursorRing').className='fill-cursor-ring'+(fillDir==='restore'?' restore':'');
});
elOutputCanvas.addEventListener('mouseleave',()=>el('fillCursor').style.display='none');

function floodFill(sx,sy,isErase){
    const w=elOutputCanvas.width,h=elOutputCanvas.height;
    const ctx=elOutputCanvas.getContext('2d');
    const out=ctx.getImageData(0,0,w,h),od=out.data,src=origData.data;
    const si=(sy*w+sx)*4;
    const sr=src[si],sg=src[si+1],sb=src[si+2];
    const tol=fillTolerance*fillTolerance*3;
    const vis=new Uint8Array(w*h);
    const stk=[sy*w+sx]; vis[sy*w+sx]=1;
    while(stk.length){
        const idx=stk.pop(),pi=idx*4;
        const dr=src[pi]-sr,dg=src[pi+1]-sg,db=src[pi+2]-sb;
        if(dr*dr+dg*dg+db*db<=tol){
            if(isErase) od[pi+3]=0;
            else{od[pi]=src[pi];od[pi+1]=src[pi+1];od[pi+2]=src[pi+2];od[pi+3]=255;}
            const px=idx%w,py=(idx/w)|0;
            if(px>0&&!vis[idx-1]){vis[idx-1]=1;stk.push(idx-1);}
            if(px<w-1&&!vis[idx+1]){vis[idx+1]=1;stk.push(idx+1);}
            if(py>0&&!vis[idx-w]){vis[idx-w]=1;stk.push(idx-w);}
            if(py<h-1&&!vis[idx+w]){vis[idx+w]=1;stk.push(idx+w);}
        }
    }
    ctx.putImageData(out,0,0);
}

/* ── 다운로드 ── */
elDownloadBtn.addEventListener('click',()=>{
    const sc=document.createElement('canvas');
    sc.width=elOutputCanvas.width;sc.height=elOutputCanvas.height;
    const sctx=sc.getContext('2d');
    if(currentBgColor!=='transparent'){sctx.fillStyle=currentBgColor;sctx.fillRect(0,0,sc.width,sc.height);}
    sctx.drawImage(elOutputCanvas,0,0);
    const a=document.createElement('a');a.download='result.png';a.href=sc.toDataURL();a.click();
});

updateUndoBtns();
/* ══════════════════════════════════════════════════════
   SaaS 99%급 고급 매트 정제 엔진
   Trimap + Laplacian + Edge Re-estimation + Decontam
══════════════════════════════════════════════════════ */

function createTrimap(alpha, w, h){
    const trimap = new Uint8Array(w*h);
    for(let i=0;i<w*h;i++){
        const a = alpha[i];
        if(a > 245) trimap[i] = 255;
        else if(a < 10) trimap[i] = 0;
        else trimap[i] = 128;
    }
    return trimap;
}

function laplacianRefine(alpha, trimap, w, h, iterations=2){
    const tmp = new Float32Array(alpha.length);
    for(let it=0; it<iterations; it++){
        for(let y=1;y<h-1;y++){
            for(let x=1;x<w-1;x++){
                const i=y*w+x;
                if(trimap[i]!==128) continue;
                let sum=0;
                sum+=alpha[i-1];
                sum+=alpha[i+1];
                sum+=alpha[i-w];
                sum+=alpha[i+w];
                tmp[i]=sum*0.25;
            }
        }
        for(let i=0;i<w*h;i++){
            if(trimap[i]===128) alpha[i]=tmp[i];
        }
    }
}

function edgeReestimate(alpha, imageData, w, h){
    const d=imageData.data;
    for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
            const i=y*w+x;
            const idx=i*4;

            const gx=d[idx+4]-d[idx-4];
            const gy=d[idx+w*4]-d[idx-w*4];
            const edge=Math.abs(gx)+Math.abs(gy);

            if(edge>35 && alpha[i]>20 && alpha[i]<235){
                alpha[i]=Math.min(255, alpha[i]*1.12);
            }
        }
    }
}

function stabilizeAlpha(alpha){
    for(let i=0;i<alpha.length;i++){
        if(alpha[i]<6) alpha[i]=0;
        if(alpha[i]>249) alpha[i]=255;
    }
}

function decontaminateColors(alpha, imageData, w, h){
    const d=imageData.data;
    const n=w*h;

    let bgR=0,bgG=0,bgB=0,bgCnt=0;

    for(let i=0;i<n;i++){
        if(alpha[i]<8){
            bgR+=d[i*4];
            bgG+=d[i*4+1];
            bgB+=d[i*4+2];
            bgCnt++;
        }
    }

    if(bgCnt===0) return;

    bgR/=bgCnt; bgG/=bgCnt; bgB/=bgCnt;

    for(let i=0;i<n;i++){
        const a=Math.max(0,Math.min(255,alpha[i]));
        const af=a/255;

        if(af>0.03 && af<0.98){
            let r=d[i*4];
            let g=d[i*4+1];
            let b=d[i*4+2];

            r=(r-bgR*(1-af))/af;
            g=(g-bgG*(1-af))/af;
            b=(b-bgB*(1-af))/af;

            d[i*4]=Math.max(0,Math.min(255,Math.round(r)));
            d[i*4+1]=Math.max(0,Math.min(255,Math.round(g)));
            d[i*4+2]=Math.max(0,Math.min(255,Math.round(b)));
        }

        d[i*4+3]=a;
    }
}

function applySaaSRefinement(alpha, imageData, W, H){
    const trimap=createTrimap(alpha,W,H);
    laplacianRefine(alpha,trimap,W,H,2);
    edgeReestimate(alpha,imageData,W,H);
    stabilizeAlpha(alpha);
    }
</script>
</body>
</html>
